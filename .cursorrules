# .cursorrules

<!-- #region DO NOT EDIT: Canonical Reference, Adoption Guidelines & Conflict Resolution -->

> 🔒 **Canonical source**
> The maintained version of this file lives at:
> https://raw.githubusercontent.com/paleite/cursorrules/refs/heads/main/.cursorrules

> 🧹 **Adoption**
> When copying this file into a project, **remove sections that do not apply** (unused frameworks, profiles, examples).
> This keeps the model’s context tight and prevents it from applying unrelated rules.

> 🔀 **Conflict resolution (Cursor Composer must follow)**
> When any rule here conflicts with existing repository configuration (ESLint, tsconfig, Tailwind, CI, env, routing):
>
> 1. **Ask exactly one clarifying question:**
>    “Should we keep the repository’s current configuration or update it to match `.cursorrules`?”
>    Include a brief diff preview if helpful.
> 2. **Apply the chosen path** in your reply by emitting patches that either
>    (a) adapt `.cursorrules` to the repository, or
>    (b) update repository files to align with `.cursorrules`.

<!-- #endregion -->

This document provides comprehensive guidance for development with Cursor's Composer, focusing on best practices for Next.js, React (TypeScript), Tailwind CSS + ShadCN, Zod, and react-query.

## Version Specifications & Project Profiles

**Framework Versions (check project-specific requirements):**
- **React Query:** v5 (use `queryOptions`, `useSuspenseQuery`, etc.)
- **Tailwind CSS:** Prefer v4, but v3 acceptable in legacy/large projects
- **TypeScript:** Use `type` by default; `interface` only when declaration merging needed

**Project Profile Detection:**
1. **Check project root for profile indicators:**
   - `nx.json` → Use [Nx Monorepo Profile](#profile-nx-monorepo)
   - `turbo.json` → Use [Turborepo Profile](#profile-turborepo)
   - `next.config.js/ts` → Additional [Next.js Profile](#profile-nextjs) considerations

2. **When in doubt:** Check `package.json` scripts and existing command patterns before generating new commands

## Output Contract (every Composer reply must follow)

1. **Applied Rules** – bullet list of the exact rules/profiles you used (quote them)
2. **Context** – what exists, what you're changing, risks/assumptions
3. **Plan** – numbered steps; chunk if big (`Subtask N of M`)
4. **Patches** – file-by-file diffs or full file drops with paths
5. **Tests** – unit + component; E2E if user flow touched. Include commands to run
6. **Usage** – code snippet showing how consumers import/use the change
7. **Checks** – exact commands: `format`, `lint`, `typecheck`, `test`, and affected Nx/Turbo cmds
8. **Rollout & Revert** – toggle flags, migration notes, revert steps
9. **Follow-ups** – tickets/todos that intentionally remain

> If the reply cannot include tests, it must explain why and create a `TODO` with owner/date.

## Core Technical Mandates

**USE**:

- **react-query** for async data fetching and caching (instead of `useEffect` + `fetch`).
- **Zod** to validate **all** API responses and form inputs.
- **Tailwind CSS + ShadCN/UI + `cn()`** for styling and class composition.
- **react-hook-form** for all form handling.
- **Zustand** for non-context or persistent client-side state.
- **@ebay/nice-modal-react** for modals.
- **@tanstack/react-table** for data tables and complex data presentation.

**AVOID**:

- `useEffect` for data fetching.
- `fetch()` directly; use a dedicated hook or API client instead.
- Inline styles; rely on Tailwind classes or `class-variance-authority` (except when required for dynamic CSS variables or features not expressible in classes).
- Mutating data and `for`-loops; favor immutability and array methods (`map`, `filter`, etc.).
- String concatenation to build class names; use the `cn()` utility.
- Default exports (except in Next.js pages).

## Essential Dependencies & Tooling

### Production Dependencies

**Core Framework & State Management:**
- `@tanstack/react-query` + `@tanstack/react-query-devtools` - Async data fetching and caching
- `@tanstack/react-table` - Tables with sorting, filtering, pagination
- `zustand` - Global client-side state management
- `zod` - Schema validation for all data

**Forms & Validation:**
- `react-hook-form` - Form handling
- `@hookform/resolvers` - Zod integration with react-hook-form
- `@hookform/devtools` - Form debugging (devDep)

**UI & Styling:**
- `@ebay/nice-modal-react` - Modal management
- `class-variance-authority` - Component style variants (same as ShadCN)
- `clsx` - Conditional class names (via `cn()` utility)
- `tailwind-merge` - Tailwind class merging (via `cn()` utility)

**HTTP & API Integration:**
- `axios` - **Primary HTTP client** (always prefer over `fetch()` directly)
- `@zodios/core` + `@zodios/plugins` - **Use when project has OpenAPI/Swagger** schemas
  - Zodios uses Axios under the hood for type-safe API clients
  - Use `import type { ZodiosPlugin } from "@zodios/core"` to create custom plugins for auth tokens and request/response interceptors
- `openapi-zod-client` - **Codegen tool that creates APIs using Zodios under the hood** from OpenAPI/Swagger specs

**Environment & Configuration:**
- `@t3-oss/env-nextjs` (or `@t3-oss/env-*`) - Type-safe environment variables
- `@sentry/nextjs` (Next.js) or `@sentry/react` (Vite/SPA) - Error tracking and monitoring

**Date & Time Handling:**
- `date-fns` - Date manipulation utilities (avoid direct date manipulation)

**Internationalization:**
- `i18next` + `react-i18next` - Core i18n framework
- `i18next-icu` - ICU message format support
- `intl-messageformat` - Message formatting
- `i18next-parser` - Extract translation keys (devDep)

### Development Dependencies

**TypeScript Configuration:**
- `@tsconfig/strictest` - Strictest TypeScript config
- `@tsconfig/nextjs` - Next.js TypeScript config (when using Next.js)
- `typescript` - TypeScript compiler

**Testing Framework:**
- `vitest` + `@vitest/coverage-v8` - Unit testing (or `bun test` for small projects)
- `@testing-library/dom` + `@testing-library/react` - React testing utilities
- `@testing-library/user-event` + `@testing-library/jest-dom` - Testing helpers
- `@types/testing-library__jest-dom` - TypeScript types for jest-dom

**Linting & Code Quality:**
- **ESLint Core:** `eslint` + `@eslint/js` + `typescript-eslint`
- **React:** `eslint-plugin-react` + `eslint-plugin-react-hooks` + `eslint-plugin-react-refresh`
- **Imports:** `eslint-plugin-import-x` (prefer over `eslint-plugin-import`)
- **Import Sorting:** `eslint-plugin-simple-import-sort` + `eslint-plugin-unused-imports`
- **Code Quality:** `eslint-plugin-promise` + `eslint-plugin-jsx-a11y`
- **Framework Specific:**
  - `@tanstack/eslint-plugin-query` - React Query best practices
  - `eslint-config-next` - Next.js specific rules (when using Next.js)
- **Testing:** `eslint-plugin-testing-library` + `eslint-plugin-vitest`
- **Configuration:** `eslint-config-prettier` + `eslint-import-resolver-typescript`

**Type Consistency Enforcement:**
```javascript
// eslint.config.mjs - enforce "type" with narrow override escape hatch
{
  files: ["**/*.{ts,tsx}"],
  rules: {
    "@typescript-eslint/consistent-type-definitions": ["error", "type"],
  },
},
{
  // Allow interfaces ONLY where declaration merging is required
  files: ["**/types/augment-*.d.ts", "**/types/augmentation/**/*.d.ts"],
  rules: { "@typescript-eslint/consistent-type-definitions": "off" },
}
```

**Optional ESLint Plugins (as needed):**
- `eslint-plugin-storybook` - Storybook specific rules
- `eslint-plugin-unicorn` - Additional code quality rules
- `eslint-plugin-jest-dom` - jest-dom specific rules
- `eslint-plugin-playwright` - Playwright testing rules

**Formatting:**
- `prettier` + `prettier-plugin-tailwindcss` - Code formatting with Tailwind class sorting

**Build & Compilation:**
- `@swc/core` - Fast TypeScript/JavaScript compiler (prefer over Babel when possible)

**Git Hooks & Commit Management:**
- `husky` - Git hooks management
- `pretty-quick` - Run Prettier on staged files
- `jira-prepare-commit-msg` - Auto-prefix commits with JIRA issue keys

**Spell Checking:**
- `@cspell/dict-sv` - Swedish dictionary (add other language dictionaries as needed)

### Key Dependency Principles

**Prefer over alternatives:**
- `axios` instead of `fetch()` directly
- `@tanstack/react-query` instead of `useEffect` + manual async state
- `eslint-plugin-import-x` instead of `eslint-plugin-import`
- `vitest` instead of Jest for new projects
- `@swc/core` instead of Babel when possible
- `date-fns` instead of moment.js or direct date manipulation

**Integration Notes:**
- **React Hooks v6+:** No longer need `eslint-plugin-react-compiler` (integrated into `eslint-plugin-react-hooks`)
- **Testing:** Use Vitest for unit tests, consider Playwright for E2E
- **TypeScript:** Always use strictest possible configuration
- **Internationalization:** Set up for SSR compatibility with initial page rendering

## Accessibility & Internationalization Checklists

### Accessibility (A11y) Requirements
**Dialog/Modal Components:**
- ✅ Focus trap implemented (focus stays within modal)
- ✅ Keyboard navigation works (Tab, Shift+Tab, Escape)
- ✅ Focus returns to trigger element on close
- ✅ ARIA labels and roles properly set (`role="dialog"`, `aria-labelledby`, `aria-describedby`)

**Interactive Elements:**
- ✅ Color contrast meets WCAG AA standards (4.5:1 for normal text)
- ✅ Keyboard navigation for all interactive elements
- ✅ Focus indicators visible and clear
- ✅ Screen reader support with proper ARIA attributes

**Forms:**
- ✅ All form inputs have associated labels
- ✅ Error messages are descriptive and announced to screen readers
- ✅ Form validation feedback is accessible

### Internationalization (i18n) Requirements
**Text Content:**
- ✅ All user-facing strings go through i18n system (no hardcoded strings)
- ✅ Use ICU message format for plurals and complex formatting
- ✅ Dates, numbers, and currencies properly localized
- ✅ Text direction (RTL/LTR) support when needed

**Implementation:**
- ✅ Translation keys follow consistent naming convention
- ✅ Context provided for translators when meaning is ambiguous
- ✅ Dynamic content (user names, counts, etc.) properly handled in translations

## Testing Policy & Error Handling

### Testing Strategy (Test Pyramid)
**Target Ratios (guidelines):**
- **Unit Tests:** 60-70% (Vitest)
- **Component/Integration Tests:** 25-35% (Testing Library + MSW)
- **E2E Tests:** 5-10% (Playwright)

**Required in Every LLM Output:**
1. **Unit tests** for pure logic and utilities
2. **Component tests** for main behavior using Testing Library
3. **E2E specs** for critical user flows (when user journeys are affected)

**Commands (Nx projects):**
- `pnpm nx run-many --target=test --all -- --coverage --reporter=default`
- `pnpm nx run-many --target=e2e --all`

**Quality Gate:**
Pull Requests must pass: `pnpm nx format:check && pnpm nx lint && pnpm nx typecheck && pnpm nx test` with zero warnings.

### Mocking Strategy (MSW)

**Install:**
```bash
pnpm add -D msw @testing-library/react @testing-library/user-event @testing-library/jest-dom
```

**`src/test/msw/handlers.ts`**
```ts
import { http, HttpResponse } from "msw";

export const handlers = [
  http.get("/api/entities", () => HttpResponse.json({ items: [] }, { status: 200 })),
];
```

**`src/test/setup-tests.ts`**
```ts
import { setupServer } from "msw/node";
import { handlers } from "./msw/handlers";
import "@testing-library/jest-dom";

const server = setupServer(...handlers);
beforeAll(() => server.listen({ onUnhandledRequest: "error" }));
afterEach(() => server.resetHandlers());
afterAll(() => server.close());
```

**`vitest.config.ts` (excerpt)**
```ts
test: { environment: "jsdom", setupFiles: ["src/test/setup-tests.ts"], css: true }
```

**Usage in component tests:**
```ts
// example.spec.tsx
import { render, screen } from "@testing-library/react";
import { http, HttpResponse } from "msw";
import { server } from "@/test/msw/setup"; // export server from setup if needed

// Override handlers for specific tests:
// server.use(http.get("/api/entities", () => HttpResponse.json({ items: [mockData] })))
```

### Error Normalization & Monitoring

**Centralized Error Handling:**
- **Single error shape:** All errors normalized to `RequestError` class
- **Boundary validation:** Validate all external data with Zod at trust boundaries
- **Global handling:** React Query cache handles errors with toast + Sentry reporting
- **User-friendly messages:** Convert technical errors to user-facing messages

**Implementation Pattern:**
```typescript
// Centralized error normalization
export class RequestError extends Error {
  constructor({ message, httpStatusCode, code, details, cause }: {
    message: string;
    httpStatusCode?: number;
    code?: string;
    details?: unknown;
    cause?: unknown;
  }) {
    super(message);
    this.name = "RequestError";
    // Set properties and maintain stack
  }
}

// Axios interceptor ensures consistent error shape
axiosClient.interceptors.response.use(
  (response) => response,
  (error) => { throw normalizeUnknownError(error); }
);

// React Query global error handling
const queryCache = new QueryCache({
  onError: (error) => {
    const normalized = normalizeUnknownError(error);
    const { severity, message } = getUserMessageFromError(normalized);
    toast[severity](message);
    reportErrorToSentry(normalized);
  }
});
```

## Working with Cursor Composer

### Before You Start

- **Figure out which rules apply to the feature you're implementing.**
  For example, if the feature involves data fetching, highlight rules about using `react-query` (and not `useEffect` or `fetch`). If it needs forms, refer to **react-hook-form** and **Zod**.

- **Repeat the relevant rules in your response.**
  This ensures transparency; the user will see which `.cursorrules` items you're following (and how).

### Large Feature Implementation Guidelines

These guidelines detail how to plan, implement, and finalize features while **chunking** tasks for **Cursor's Composer**. The goal is to avoid exceeding the LLM context window and to handle **big** features incrementally.

#### 1. Planning Phase

1. **Check `progress.md`** for a corresponding feature section.

   - If none exists, create an outline in `[ ]` checklist format covering:
     - Feature scope & expected behavior.
     - Key components/modules to add or modify.
     - Filenames to create or change (and what they should contain).
     - Dependencies or prerequisite steps.
     - Potential edge cases & error handling.
     - Adherence to `.cursorrules` (Zod validations, react-query, tailwind, syntax & style, file structure, etc.).

2. **Define the High-Level Feature**

   - Clearly articulate what the feature needs to do and any constraints (like design specs or acceptance criteria).

3. **Chunk the Feature**
   - If the request is too large to fit into the LLM's context, break it into smaller tasks or subtasks.
   - Label each subtask (e.g., "Subtask 1 of 5").
   - This is like splitting an EDM set into multiple smaller segments—each one has its own distinct focus, but they form a unified whole.

#### 2. Implementation Phase

1. **Work on a Single Chunk**

   - For each subtask, pass any relevant code snippets or references to Cursor.
   - If multiple files are affected, focus on smaller sections of code in each iteration.

2. **Context Carryover**

   - Remind Cursor what was done in previous chunks.
   - If Cursor "forgets," re-supply the necessary code or instructions from the previous step.

3. **Feedback Loops**

   - After generating code for each chunk, review it.
   - If errors or inconsistencies appear, correct them or clarify your instructions.
   - Confirm or reject each subtask's output before moving on.

4. **Keep `progress.md` Updated**
   - Check off finished tasks, add notes or revisions as needed.

#### 3. Review & Documentation Phase

1. **Testing and Validation**

   - After each chunk or once the chunk is completed, run tests or do a manual check.
   - Fix issues in the code, either manually or by prompting Cursor.
   - For new or existing code, write or update relevant unit tests, integration tests, etc.

2. **Update Project Docs**

   - Document changes in `CHANGELOG.md`.
   - If your code has any complex logic or custom hooks, add inline comments or short usage docs.

3. **Confirm the Feature Meets the Outlined Goals**
   - Cross-check with the initial plan (in `progress.md`) to ensure no steps or edge cases are missed.

#### 4. Finalization & Commit

1. **Integrate Changes**

   - Once all chunks are approved, unify them into the feature branch or main branch (depending on your branching strategy).

2. **Final Test & Code Review**

   - Do a final pass for formatting (ESLint, Prettier), project conventions, and run `typecheck` if applicable.

3. **Post Summary**
   - In `progress.md`, note that the feature is complete and reference any relevant PR or commit hashes.

### Additional Cursor Composer Guidance

1. **Short Context Window**

   - Acknowledge that Cursor's context window has limits. For large code sections, break them into smaller snippets when you prompt.

2. **New vs. Existing Codebases**

   - These chunking and carryover rules apply equally whether you're introducing a brand-new feature or modifying an established codebase.

3. **Resilient to Mistakes**

   - The LLM can introduce errors. Use iterative feedback loops: generate code, then review and correct.

4. **Adhere to Project Decisions**

   - Always remember to use the frameworks, libraries, and style decisions listed in "Core Technical Mandates."

5. **User Confirmation**
   - After each subtask, prompt for user feedback or additional clarifications.

## Project Structure and Organization

### ShadCN/UI & Tailwind CSS Setup

**When bootstrapping a new project or adding ShadCN/Tailwind to an existing project:**

1. **Always use ShadCN's init command** to set up both ShadCN and Tailwind CSS:
   ```bash
   pnpm dlx shadcn@latest init -d
   ```

2. **Tailwind CSS version strategy:**
   - **Prefer v4** for new/small projects
   - **v3 is acceptable** for large projects or when in monorepo with mixed versions
   - In monorepos: v4 can be root version with v3 in specific app package.json if needed
   - Only upgrade v3→v4 in projects that aren't huge or complex

3. **ShadCN components strategy:**
   ```bash
   pnpm dlx shadcn@latest add <component-name>
   ```
   - **Default approach:** Install only components you actually use (`shadcn add button dialog toast`)
   - **For component discovery:** Create a dedicated catalog/storybook app with `shadcn add --all`
   - **Per-app installation:** Always use `shadcn add <component>` to match each app's Tailwind version
   - **Bundle size:** Installing specific components prevents unnecessary bloat

4. **Project structure after ShadCN setup:**
   - ShadCN components will be added to `src/components/ui/`
   - Tailwind configuration will be updated automatically
   - The `cn()` utility will be available at `src/lib/utils.ts`

### File Structure

- **kebab-case** for filenames.
- **`.tsx`** for TypeScript with JSX; **`.ts`** otherwise.
- Test files: `[filename].test.ts` or `[filename].test.tsx`.

### Folder Structure

```
src/
  app/  // The Next.js app structure (pages, layouts, etc.)
    users/  // Feature-specific files for the "users" feature
      page.ts // Imports the CreateUserForm
      create-user-form.tsx  // Exports a component using react-hook-form
      use-create-user-modal.tsx // Exports a hook from @ebay/nice-modal-react
  components/ // React components
    ui/ // Reusable UI components (e.g., ShadCN components)
    common/ // Reusable across multiple features
    form-input/ // Standard form input components
  contexts/ // React context providers
    auth-context.ts
    user-context.ts
  lib/  // Project-level libraries/utilities
    api.ts
    constants.ts
    postchain-client.ts
    utils/  // Generic utility functions
      format.ts
      convert.ts
  hooks/  // Global React hooks
  providers/  // React context providers
    auth-provider.ts
    user-provider.ts
  queries/  // React Query queries/mutations
    users-queries.ts
    posts-queries.ts
  schemas/  // Zod schemas
    user-schema.ts
    product-schema.ts
  stores/ // Zustand or other state management
    user-store.ts
    settings-store.ts
  forms/ // Form components organized by entity
```

### Exports and Imports

- Remove unused exports regularly.
- Export next to declarations; avoid placing all exports at the file bottom.
- Avoid default exports (except for Next.js page components, layout components, and error/loading/not-found pages in App Router).
- Import with short paths (e.g., `@/components/ui`) and prefer `@/*` from the project root.
- Keep import paths as concise as possible.

### Static Export Considerations

**Only apply these rules when using Next.js static export (`output: "export"`):**

- Convert server components to client components when they need interactivity or client-side data fetching.
- Avoid server-side features: middleware, API routes, server actions, ISR, SSR.
- Use query parameters instead of dynamic routes for data filtering and selection.
- All dynamic data must be fetched client-side after route hydration using react-query.
- Ensure all components handle client-side-only rendering (avoid dependencies on server-side rendering lifecycle).
- Use `next.config.ts` to configure static export settings properly.

### Next.js Deployment Configuration

- **Always set `basePath` when deploying to non-root paths**:
  ```typescript
  // For production environments with subpath deployment
  export const basePath =
    process.env.NODE_ENV === "production"
      ? `/your_app_path/${process.env.DEPLOYMENT_ID}/static`
      : "";

  const nextConfig: NextConfig = {
    basePath,
    // other config...
  };
  ```

- **Configure static exports correctly**:
  ```typescript
  const nextConfig: NextConfig = {
    output: "export",
    images: {
      unoptimized: true, // Required for static exports
    },
    // other config...
  };
  ```

- **Handle redirects conditionally for development vs. static export**:
  ```typescript
  ...(process.env.NODE_ENV === "development"
    ? {
        // Redirects only in development
        redirects: async () => [
          {
            source: "/docs",
            destination: env.NEXT_PUBLIC_DOCS_URL,
            permanent: true,
          },
        ],
      }
    : {
        // Static export configuration for production
        output: "export",
      }),
  ```

- **GitHub Pages Deployment Workflow**:
  For deploying Next.js sites to GitHub Pages, use a workflow like this:
  ```yaml
  name: Deploy Next.js site to Pages

  on:
    push:
      branches: ["main"]
    workflow_dispatch:

  permissions:
    contents: read
    pages: write
    id-token: write

  concurrency:
    group: "pages"
    cancel-in-progress: false

  jobs:
    build:
      runs-on: ubuntu-latest
      steps:
        - name: Checkout
          uses: actions/checkout@v4

        - name: Setup Node.js
          uses: actions/setup-node@v4
          with:
            node-version-file: ".nvmrc"

        - name: Enable Corepack
          run: corepack enable

        - name: Setup Pages
          uses: actions/configure-pages@v5
          with:
            # Automatically injects basePath for GitHub Pages
            static_site_generator: next

        - name: Get pnpm store directory
          shell: bash
          run: |
            echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_ENV

        - uses: actions/cache@v4
          name: Setup pnpm cache
          with:
            path: ${{ env.STORE_PATH }}
            key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
            restore-keys: |
              ${{ runner.os }}-pnpm-store-

        - name: Restore Next.js cache
          uses: actions/cache@v4
          with:
            path: |
              .next/cache
            key: ${{ runner.os }}-nextjs-${{ hashFiles('**/pnpm-lock.yaml') }}-${{ hashFiles('**.[jt]s', '**.[jt]sx') }}
            restore-keys: |
              ${{ runner.os }}-nextjs-${{ hashFiles('**/pnpm-lock.yaml') }}-

        - name: Install dependencies
          run: pnpm install

        - name: Build with Next.js
          run: pnpm next build

        - name: Upload artifact
          uses: actions/upload-pages-artifact@v3
          with:
            path: ./out

    deploy:
      environment:
        name: github-pages
        url: ${{ steps.deployment.outputs.page_url }}
      runs-on: ubuntu-latest
      needs: build
      steps:
        - name: Deploy to GitHub Pages
          id: deployment
          uses: actions/deploy-pages@v4
  ```
  The `actions/configure-pages@v5` action with `static_site_generator: next` automatically:
  - Injects the correct `basePath` for GitHub Pages
  - Disables server-side image optimization

## Development Standards

### Code Readability

- Prioritize **readability** over conciseness.
- Maintain **consistent naming**.
- Use **descriptive names** for functions, variables, and booleans (e.g., `isUserAuthenticated()`).
- Rename identifiers if their purpose changes.
- **When generating new code**:
  - Prefer **explicit** syntax over shorthand.
  - Example: `React.FunctionComponent` instead of `React.FC`, `disabled={true}` instead of just `disabled`.
- Comment and document any workarounds or suboptimal solutions.
- Break large functions into smaller, testable ones.
- Prefer early returns to reduce nesting.
- Avoid magic numbers; use named constants.
- Use capital letters for constants.

### Code Formatting

- Configure Prettier with Tailwind plugin for consistent class ordering:
  ```js
  // prettier.config.js or .prettierrc.js
  module.exports = {
    plugins: ["prettier-plugin-tailwindcss"],
    tailwindFunctions: ["cva", "cn"],
  };
  ```
- This ensures Tailwind classes follow the recommended sort order
- Also preserves class ordering in `cva` and `cn` function calls
- Run format checks during CI and as pre-commit hooks
- Maintain consistent indentation and line endings

### Pre-commit Hooks with Husky

For projects requiring automated code quality checks, set up Husky:

#### Basic Setup

```bash
# Install Husky and pretty-quick for formatting
pnpm add -D husky pretty-quick

# Configure husky
pnpm exec husky init
```

#### Pre-commit Hook

```sh
#!/usr/bin/env sh
. "$(dirname -- "$0")/_/husky.sh"

# Format staged files
$(pnpm bin)/pretty-quick --staged
```

#### Pre-push Hook

For type checking before pushing to the remote repository:

```bash
# Create a pre-push hook
pnpm exec husky add .husky/pre-push "pnpm run typecheck"
```

```sh
#!/usr/bin/env sh
. "$(dirname -- "$0")/_/husky.sh"

# Run full type checking
pnpm run typecheck
```

#### Prepare Commit Message Hooks

Use prepare-commit-msg hooks to automatically prefix commits with JIRA issue keys.

**JIRA Issue Key Integration (Basic)**:
```sh
#!/usr/bin/env sh
. "$(dirname -- "$0")/_/husky.sh"

$(pnpm bin)/jira-prepare-commit-msg $1
```

**Advanced JIRA Integration (Without Dependencies)**:
```sh
#!/usr/bin/env sh
. "$(dirname -- "$0")/_/husky.sh"

# Automatically prepend the JIRA issue-key to the commit message
readonly COMMIT_MESSAGE_PATH="$1"
readonly COMMIT_TYPE="$2"

# Get current branch name, handling various git states
GIT_BRANCH=$(git branch --show-current || git rev-parse --abbrev-ref HEAD)
if [ -z "$GIT_BRANCH" ]; then
  REV_PARSE_PATH=$(git rev-parse --git-path rebase-merge)
  if test -d "${REV_PARSE_PATH}"; then
    REVISION=$(cat "${REV_PARSE_PATH}"/head-name)
    GIT_BRANCH=${REVISION##refs/heads/}
  fi
fi

# Don't proceed if branch name can't be determined
if [ -z "$GIT_BRANCH" ]; then
  echo "$(tput setaf 1)error$(tput sgr0) No branch found"
  exit 1
fi

# Skip for merge commits
if [ "$COMMIT_TYPE" = "commit" ] || [ "$COMMIT_TYPE" = "merge" ]; then
  exit
fi

# Extract JIRA issue key from branch name (format: PROJECT-123)
ISSUE_KEY=$(node -e 'console.log(process.argv.pop().split("/").reduce(((e,o)=>(o=/^[A-Z]{2,}-\d+/.exec(o)?.pop())?o:e),""));' "${GIT_BRANCH}")

# Skip if no issue key found
if [ -z "$ISSUE_KEY" ]; then
  echo "$(tput setaf 3)warning$(tput sgr0) No issue key found in branch '${GIT_BRANCH}'"
  exit
fi

# Skip if message already contains the issue key
if grep -q "^${ISSUE_KEY}\b" "$COMMIT_MESSAGE_PATH"; then
  exit
fi

# Prepend issue key to commit message
sed -i -e "1s/^/${ISSUE_KEY}: /" "$COMMIT_MESSAGE_PATH"
```

**Installation Steps**:

For JIRA integration:
```bash
# Option 1: Use jira-prepare-commit-msg package
pnpm add -D jira-prepare-commit-msg

# Add the prepare-commit-msg hook
pnpm exec husky add .husky/prepare-commit-msg "$(pnpm bin)/jira-prepare-commit-msg \$1"

# Option 2: Use the custom script (no dependencies)
# Copy the advanced script above to .husky/prepare-commit-msg
```

These hooks ensure:
- Automatic JIRA issue key detection from branch names
- Proper prefixing of commit messages with issue keys
- Graceful handling of edge cases like merge commits and branches without issue keys

### Syntax & Programming Style

- **Use strict mode** for production applications:

  ```typescript
  // TypeScript strictness through tsconfig.json
  {
    "compilerOptions": {
      "strict": true,
      // Optional additional strict flags for mature projects
      "noUncheckedIndexedAccess": true,
      "exactOptionalPropertyTypes": true
    }
  }
  ```

  ```jsx
  // For React, use Strict Mode in development
  import { StrictMode } from 'react';

  function App() {
    return (
      <StrictMode>
        <MainComponent />
      </StrictMode>
    );
  }
  ```

- Use nullish coalescing (`??`) over logical OR (`||`) for default values.
- Prefer immutable programming and pure functions.
- Use appropriate error types (`TypeError`, `RangeError`, etc.).
- Add default case type checking in `switch` statements.

### Command Line

- **When generating code** (not editing existing), use **long flags**:
  - `--no-emit` instead of `-n`.
  - `prettier --write .` instead of `prettier -w .`.
  - `next lint --config eslint.config.mjs` instead of `next lint -c eslint.config.mjs`.
- Document shell scripts thoroughly.
- Name environment variables clearly.
- Use descriptive names for scripts in `package.json`.
- Use colorized output for warnings/errors.
- Use explicit exit codes for error conditions.

### Package Manager Selection

- **Prefer pnpm** over npm or Yarn for all projects when possible:
  - Superior disk space efficiency with content-addressable storage
  - Strict dependency resolution that prevents phantom dependencies
  - Built-in monorepo support with workspaces
  - Faster installation times
  - Most secure dependency resolution

- **Alternatively, use Bun** for projects where you can accept ecosystem trade-offs for performance:
  - Extremely fast package installation and runtime
  - Built-in test runner and bundler
  - Native TypeScript support
  - Growing npm package compatibility (verify critical dependencies work before adopting)

- **Setup for pnpm**:
  ```json
  // package.json
  {
    "packageManager": "pnpm@latest"
  }
  ```

- **Lockfile guidance**:
  - Commit `pnpm-lock.yaml` or `bun.lockb` to version control
  - Never modify lockfiles manually
  - Update dependencies with `pnpm update` or appropriate commands
  - Run `pnpm install --frozen-lockfile` in CI environments

- **For existing projects**:
  - Do not switch package managers mid-project without full team agreement
  - When switching, delete the old lockfile and `node_modules` completely

### Node.js setup

#### Initial Setup

- **When initializing a new repository**, use LTS Node and create .nvmrc:
  ```bash
  # Switch to LTS version
  nvm use --lts

  # Create .nvmrc with current Node version
  node -v > .nvmrc
  ```

- **Always include `.nvmrc`** with the exact Node.js version to ensure consistency across development environments

#### Dynamic Version Management

- **Use `.nvmrc` to drive `package.json` settings** for CI/CD compatibility:
  ```json
  // package.json
  {
    "engines": {
      "node": ">=18.0.0",
      "pnpm": ">=8.0.0"
    },
    "packageManager": "pnpm@8"
  }
  ```

- For CI/CD pipelines, use dynamic version extraction:
  ```yaml
  # GitHub Actions workflow example
  jobs:
    build:
      runs-on: ubuntu-latest
      steps:
        - uses: actions/checkout@v4
        - name: Read .nvmrc
          run: echo "NODE_VERSION=$(cat .nvmrc)" >> $GITHUB_ENV
        - uses: actions/setup-node@v4
          with:
            node-version: ${{ env.NODE_VERSION }}
            cache: 'pnpm'
        - run: corepack enable
        - run: pnpm install --frozen-lockfile
  ```

- **Enforce Node.js version usage** in development with:
  ```bash
  pnpm exec check-node-version --package
  ```

- **When checking out a new codebase**, immediately look for and if necessary add:
  - `.nvmrc` for Node.js version management
  - `"packageManager"` field in package.json
  - Proper lockfile for the selected package manager

- Ensure `@types/node` is installed and matches the same Node.js version

### Monorepo Configuration

- Use **Turborepo** for monorepo workspaces that need advanced build optimizations and caching:
  ```json
  // turbo.json
  {
    "$schema": "https://turbo.build/schema.json",
    "globalDependencies": ["tsconfig.json"],
    "pipeline": {
      "build": {
        "dependsOn": ["^build"],
        "outputs": [".next/**", "dist/**"]
      },
      "lint": {},
      "dev": {
        "cache": false,
        "persistent": true
      },
      "generate": {
        "dependsOn": [],
        "outputs": ["src/generated/**"]
      }
    }
  }
  ```

- **For simpler monorepos** without complex build dependencies, pnpm workspaces may be sufficient:
  ```json
  // pnpm-workspace.yaml
  packages:
    - 'apps/*'
    - 'packages/*'
  ```

- Configure shared dependencies carefully:
  - Use `"*"` for internal workspace packages
  - Pin exact versions for external packages in root
  - Consider `pnpm.overrides` for enforcing specific versions

### Code Generation

Use automated code generation for schema-driven development when it provides clear benefits. Include a `generate` script in package.json for manual execution when schemas change.

#### When to Use Code Generation

- **Complex schemas** with frequent changes (GraphQL, OpenAPI)
- **Large icon sets** that need React component conversion
- **CMS integration** requiring type safety
- **API clients** with many endpoints

#### When NOT to Use Code Generation

- **Simple, stable APIs** with few endpoints
- **Small projects** where manual type definitions are manageable
- **One-off integrations** that won't change frequently
- **When debugging generated code** becomes more complex than writing it manually

#### Core Generation Tools

- **GraphQL Schema**: Use graphql-codegen for type-safe operations
  ```json
  {
    "scripts": {
      "generate": "graphql-codegen"
    }
  }
  ```

- **OpenAPI/Swagger**: Generate Zod schemas and types from OpenAPI specs
  ```json
  {
    "scripts": {
      "generate": "openapi-zod-client https://api.example.com/swagger.json --strict-objects --output src/generated/schemas/api.ts"
    }
  }
  ```

  Alternative: For complex API clients with React Query integration:
  ```json
  {
    "scripts": {
      "generate": "openapi-codegen gen admin"
    }
  }
  ```

- **SVG Icons**: Transform SVGs into React components
  ```json
  {
    "scripts": {
      "generate": "svgr --filename-case kebab --icon --jsx-runtime automatic --out-dir src/generated/icons --no-prettier --ref --typescript -- src/assets/icons"
    }
  }
  ```

- **CMS Integration**: Generate types from CMS schemas
  ```json
  {
    "scripts": {
      "generate": "sanity-codegen"
    }
  }
  ```

- **Blockchain/Custom APIs**: Use specialized generators
  ```json
  {
    "scripts": {
      "generate": "source .env; docker run -v .:/usr/app \"${CLI_IMAGE}\" chr generate-client-stubs --typescript"
    }
  }
  ```

#### Configuration Best Practices

- **Standardize Output Location**: Place all generated code in `src/generated/`
- **Version Control Strategy**:
  - **Commit generated files** for stable, infrequently changing schemas
  - **Gitignore generated files** for rapidly changing schemas (run generation in CI)
- **Always commit generator config files** (e.g., `codegen.ts`)
- **Document regeneration process** in project README
- **Monorepo Setup**: Use Turborepo to orchestrate generation across workspaces
  ```json
  {
    "scripts": {
      "generate": "turbo run generate"
    }
  }
  ```

#### Generation Workflow

1. Define schemas/APIs first (contract-first development)
2. Configure generators to create type-safe interfaces
3. Implement features using the generated types
4. Run generation on schema changes
5. Validate generated output is type-compatible with existing code

#### Key Tools Configuration

- **GraphQL Codegen**:
  ```typescript
  // codegen.ts
  export default {
    schema: "schema.graphql",
    documents: ["src/**/*.graphql"],
    generates: {
      "src/generated/graphql.ts": {
        plugins: ["typescript", "typescript-operations", "typescript-react-query"],
        config: {
          fetcher: "@/lib/graphql-fetcher#fetchData",
          enumsAsTypes: true
        }
      }
    }
  };
  ```

- **OpenAPI Codegen**:
  ```typescript
  // openapi-codegen.config.ts
  import { defineConfig } from "@openapi-codegen/cli";
  import { generateSchemaTypes, generateReactQueryComponents } from "@openapi-codegen/typescript";

  export default defineConfig({
    admin: {
      from: { source: "url", url: "https://api.example.com/schema.json" },
      outputDir: "src/generated/admin",
      to: async (context) => {
        const filenamePrefix = "adminApi";
        const clients = await generateReactQueryComponents(context, {
          filenamePrefix,
          clientName: "AdminApi"
        });
        const schemas = await generateSchemaTypes(context, { filenamePrefix });
        return [...clients, ...schemas];
      }
    }
  });
  ```

### `package.json` Scripts

Include (or ensure you have) scripts for:

- `build`
- `dev`
- `format`
- `lint`
- `prepare`
- `spellcheck`
- `start`
- `typecheck`

Example snippet to add if missing:

```json
{
  "scripts": {
    "lint": "eslint --cache",
    "format": "prettier --write .",
    "prepare": "husky",
    "spellcheck": "cspell --config=cspell.json \"**/*.{cjs,js,md,mjs,ts,tsx}\" --no-progress --show-context --show-suggestions",
    "typecheck": "tsc --noEmit"
  }
}
```

### Spell Checking Configuration

Always include a `cspell.json` file in the project root to ensure consistent spell checking across the team and in CI/CD pipelines.

```json
// cspell.json
{
  "$schema": "https://raw.githubusercontent.com/streetsidesoftware/cspell/main/cspell.schema.json",
  "version": "0.2",
  "language": "en",
  "useGitignore": true,
  "allowCompoundWords": true,
  "ignorePaths": [
    // Dependencies
    "node_modules",
    // Build outputs
    "dist",
    ".next",
    "build",
    // Generated files
    "src/generated/**",
    "**/generated/**",
    // Large binary or lock files
    "pnpm-lock.yaml",
    "yarn.lock",
    "package-lock.json",
    "bun.lockb",
    "*.min.*",
    "*.mp4",
    "*.webm",
    "*.glb",
    // Environment and configuration
    ".env",
    ".env.*",
    // Test files (customize as needed)
    "*.test.*",
    "*.spec.*",
    "*.cy.*",
    "*.stories.*",
    "**/__fixtures__",
    "**/cypress",
    "**/fixtures",
    "**/test-data"
  ],
  "ignoreRegExpList": [
    // Escape sequences
    "\\\\(.*\\\\)",
    // Comments
    "\\/\\*[\\s\\S]*?\\*\\/",
    // Template literals
    "\\{\\{[\\s\\S]*?\\}\\}",
    // Possessives
    "//'s+",
    // File extensions
    "\\w+\\.\\w+",
    // Import statements
    "import\\s+.+?\\s+from\\s+'.*'",
    // Hash patterns and long identifiers
    "[a-f\\d]{32,}",
    // Data URIs
    "data:([a-z]+/[a-z0-9-+.]+);base64,([A-Za-z0-9+/=])"
  ],
  "words": [
    // Package managers & build tools
    "pnpm",
    "lerna",
    "turborepo",
    "vite",
    "tsup",
    "esbuild",
    "rollup",
    "npmrc",
    "nvmrc",

    // Frameworks & libraries
    "nextjs",
    "preact",
    "svelte",
    "astro",
    "qwik",
    "fastify",
    "nestjs",
    "trpc",
    "tanstack",
    "zustand",
    "xstate",
    "jotai",
    "valtio",
    "immer",
    "zod",
    "zodios",
    "viem",
    "wagmi",
    "ethers",
    "gsap",
    "framer",
    "shadcn",
    "tailwindcss",

    // UI libraries & components
    "lucide",
    "heroicons",
    "radix",
    "mantine",
    "chakra",
    "headlessui",
    "vaul",
    "sonner",
    "contentful",
    "storybook",
    "nextui",
    "swiper",
    "clsx",
    "clsxm",
    "cva",
    "cmdk",
    "oklch",
    "WCAG",

    // Testing & tooling
    "vitest",
    "uvu",
    "jest",
    "cypress",
    "testid",
    "lcov",
    "codecov",
    "typecheck",
    "tsbuildinfo",
    "codemod",
    "svgr",
    "rehype",
    "shiki",

    // Web3 & blockchain
    "secp256k1",
    "merkle",
    "chromia",
    "rell",
    "brid",
    "brids",
    "dapp",
    "dapps",
    "promievent",
    "gtxclient",
    "secp",
    "ierc",
    "dalarnia",
    "hbridge",

    // File formats & data
    "webp",
    "avif",
    "webm",
    "jsonld",
    "superjson",
    "toml",
    "yaml",
    "graphql",
    "openapi",
    "camelcase",
    "kebabcase",
    "dataurl",

    // Auth & identity
    "supabase",
    "oauth",
    "oidc",
    "jwks",
    "cognito",
    "signin",
    "signup",
    "signout",
    "onboarded",

    // Payment providers
    "klarna",
    "vipps",
    "stripe",
    "paypal",
    "gtin13",

    // Analytics & tracking
    "gtag",
    "matomo",
    "plausible",
    "mixpanel",
    "metrica",
    "ganalytics",

    // Deployment & hosting
    "vercel",
    "netlify",
    "cloudflare",
    "amazonaws",
    "digitalocean",
    "heroku",

    // Development patterns
    "memoize",
    "debounce",
    "throttle",
    "middleware",
    "middlewares",
    "codegen",
    "codebase",
    "monorepo",
    "vendored",
    "treeshake",
    "transpile",
    "polyfill",

    // Terminal utilities
    "setaf",
    "tput"
  ],
  "overrides": [
    {
      "filename": "**/locales/sv/**/*.json",
      "language": "en,sv"
    },
    {
      "filename": "**/locales/de/**/*.json",
      "language": "en,de"
    }
  ],
  "import": []
}
```

#### Key Configuration Features

- **Comprehensive Technical Dictionary**: Over 100 commonly used technical terms pre-approved and categorized by domain
- **Multi-Language Support**: Configuration for projects with internationalization (Swedish, German, etc.)
- **Smart Ignores**:
  - Generated code (all common output directories)
  - Build artifacts and bundle files
  - Environment and configuration files
  - Test fixtures and mock data
  - Binary and media files
  - Lock files from all package managers

- **RegExp Pattern Ignores**: Common code patterns that frequently trigger false positives:
  - Import statements
  - File paths with extensions
  - Long hashes and cryptographic identifiers
  - Base64 data URIs
  - Template literals
  - Code comments with non-dictionary terms

- **Optimized for Modern Workflows**:
  - Blockchain/Web3 terminology
  - Frontend frameworks and libraries
  - Testing and tooling identifiers
  - Payment providers
  - Authentication systems

#### Implementation

1. Place `cspell.json` in the project root directory
2. Configure the spell checking script in package.json:
   ```json
   "scripts": {
     "spellcheck": "cspell --config=cspell.json \"**/*.{ts,tsx,js,jsx,md,mdx}\" --no-progress"
   }
   ```
3. Add to pre-commit hooks or CI pipeline
4. Extend with domain-specific terms as needed

For projects with non-English content or documentation, add the appropriate language dictionaries:

```bash
pnpm add -D @cspell/dict-sv @cspell/dict-de-de
```

Then update the imports section of cspell.json:
```json
"import": [
  "@cspell/dict-sv/cspell-ext.json",
  "@cspell/dict-de-de/cspell-ext.json"
]
```

### `tsconfig.json`

- Use `@tsconfig/strictest`.
- Also use `@tsconfig/nodeXX` (replace XX with your Node version).
- Use `@tsconfig/next` if you're on Next.js.

**Example** (Next.js):

```json
{
  "extends": [
    "@tsconfig/strictest/tsconfig.json",
    "@tsconfig/next/tsconfig.json"
  ],
  "compilerOptions": {
    "baseUrl": ".",
    "paths": { "@/*": ["./*"] }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
```

### ESLint Configuration

Use ESLint's new flat config format with the following plugins and configurations. This setup enforces code quality, React best practices, and TypeScript correctness.

#### Essential Plugins

```bash
# Core and TypeScript
pnpm install -D eslint @eslint/js typescript-eslint @typescript-eslint/parser

# React
pnpm install -D eslint-plugin-react eslint-plugin-react-hooks
```

**Recommended for larger projects:**
```bash
# Import management
pnpm install -D eslint-plugin-import-x eslint-plugin-simple-import-sort eslint-plugin-unused-imports

# Additional quality tools
pnpm install -D eslint-plugin-promise
```

**Project-specific additions:**
```bash
# Next.js projects
pnpm install -D @next/eslint-plugin-next

# Projects using TanStack Query
pnpm install -D @tanstack/eslint-plugin-query

# Projects targeting React 19+ with compiler
pnpm install -D eslint-plugin-react-refresh eslint-plugin-react-compiler
```

#### Configuration Structure (`eslint.config.js`)

Use ESLint's flat config format with modular configuration:

```js
// eslint.config.js
import js from "@eslint/js";
import nextPlugin from "@next/eslint-plugin-next";
import pluginQuery from "@tanstack/eslint-plugin-query";
import tsParser from "@typescript-eslint/parser";
import eslintPluginImportX from "eslint-plugin-import-x";
import pluginPromise from "eslint-plugin-promise";
import react from "eslint-plugin-react";
import reactCompiler from "eslint-plugin-react-compiler";
import reactHooks from "eslint-plugin-react-hooks";
import reactRefresh from "eslint-plugin-react-refresh";
import simpleImportSort from "eslint-plugin-simple-import-sort";
import unusedImports from "eslint-plugin-unused-imports";
import globals from "globals";
import { config as tsEslintConfig, configs as tsEslintConfigs } from "typescript-eslint";

// Config implementation
export default tsEslintConfig(
  // Base configurations
  // TypeScript configurations
  // Plugin configurations
  // File-specific overrides
);
```

#### Plugin Purposes

- **TypeScript Integration**:
  - `typescript-eslint` - Strict type checking rules
  - `@typescript-eslint/parser` - Enables ESLint to understand TypeScript

- **React Best Practices**:
  - `eslint-plugin-react` - Core React patterns (component definition, prop naming)
  - `eslint-plugin-react-hooks` - Enforces Rules of Hooks
  - `eslint-plugin-react-refresh` - Optimizes for Fast Refresh compatibility
  - `eslint-plugin-react-compiler` - Ensures compatibility with React Compiler (Forget)

- **Import Management**:
  - `eslint-plugin-import-x` - Import validation and restrictions
  - `eslint-plugin-simple-import-sort` - Consistent import ordering
  - `eslint-plugin-unused-imports` - Automatic removal of unused imports

- **Framework Specific**:
  - `@next/eslint-plugin-next` - Next.js best practices and patterns
  - `@tanstack/eslint-plugin-query` - TanStack Query optimization rules

- **Code Quality**:
  - `eslint-plugin-promise` - Promise handling best practices

#### Key Rule Configurations

- **TypeScript Strictness**:
  - Enforced nullish coalescing over logical OR
  - Consistent type definitions per project conventions
  - Proper type imports

- **React Patterns**:
  - Boolean prop naming convention (`isX`, `hasX`, `showX`)
  - Self-closing component enforcement
  - JSX prop sorting
  - Component definition style consistency
  - Prevention of unstable nested components

- **Import Organization**:
  - Grouping imports by source type (React, Next.js, node_modules, local)
  - Automatic removal of unused imports
  - Type import separation

- **Framework Conventions**:
  - Exceptions for Next.js page components
  - Special rules for UI component libraries
  - Prevention of direct Radix UI imports outside UI components

#### Implementation Notes

- Use `"react/boolean-prop-naming"` to enforce consistent boolean prop names
- Configure `"react/jsx-sort-props"` for consistent prop ordering
- Implement `"simple-import-sort/imports"` with custom grouping
- Use file overrides to exempt certain files from specific rules
- Enable React compiler checks for better performance
- Add specialized rules for UI components directory

## Technology-Specific Standards

### TypeScript

- Leverage **discriminated unions** for state variations.
- Use `as const` to preserve literal types.
- Prefer `satisfies` over `as` for safer type compatibility.
- **Use `type` by default** for all type definitions; only use `interface` when declaration merging is specifically needed.
- Avoid `any`, `as`, and `is`; use `zod` for strict type checks.
- Employ utility types (`Partial`, `Pick`, `Omit`, etc.).
- Use the strictest TS config available.

### Tailwind CSS & ShadCN

- **Prefer Tailwind CSS v4** over v3 for all new projects and upgrades.
- Use `import { cn } from "@/lib/utils";` to merge conditional classes.
- **Never** build class names with string concatenation.
- **Avoid inline styles**; rely on Tailwind or `class-variance-authority`.
- Extend Tailwind config for design tokens and to avoid "magic numbers."
- **ALWAYS use ShadCN CSS variables** over regular Tailwind color classes for theming consistency.
- Use `cva` from `class-variance-authority` to handle component styling variations.

#### CSS Variables and Theming

**CSS Variable Usage:**
- **MUST** use CSS variables (e.g., `bg-muted`, `text-foreground`) instead of regular Tailwind classes (e.g., `bg-zinc-500`, `text-gray-900`)
- Use appropriate existing CSS variables based on component purpose:
  - `bg-background text-foreground` - Main app background/text
  - `bg-card text-card-foreground` - Card containers
  - `bg-muted text-muted-foreground` - Subdued/secondary content
  - `bg-primary text-primary-foreground` - Primary actions/highlights
  - `bg-secondary text-secondary-foreground` - Secondary actions
  - `bg-accent text-accent-foreground` - Accent elements
  - `bg-destructive text-destructive-foreground` - Error/danger states
  - `border-border` - Standard borders
  - `border-input` - Form input borders
  - `ring-ring` - Focus rings

**Adding New CSS Variables:**
When no fitting CSS variable exists for a color need, add a new CSS variable with semantic naming:

1. **Naming Convention:** `--<component>-<role>-<state>`
   - Component name first (e.g., `notification`, `tooltip`)
   - Role second (e.g., `border`, `foreground`, `ring`)
   - State last if needed (e.g., `success`, `warning`, `error`)

2. **Example - Adding notification component variables:**
```css
:root {
  --notification: oklch(0.98 0.05 100);
  --notification-foreground: oklch(0.22 0.02 100);
  --notification-border: oklch(0.90 0.02 100);
  --notification-border-success: oklch(0.92 0.15 142);
  --notification-border-warning: oklch(0.84 0.16 84);
}

.dark {
  --notification: oklch(0.25 0.03 100);
  --notification-foreground: oklch(0.95 0.03 100);
  --notification-border: oklch(0.45 0.03 100);
  --notification-border-success: oklch(0.41 0.11 142);
  --notification-border-warning: oklch(0.41 0.11 46);
}

@theme inline {
  --color-notification: var(--notification);
  --color-notification-foreground: var(--notification-foreground);
  --color-notification-border: var(--notification-border);
  --color-notification-border-success: var(--notification-border-success);
  --color-notification-border-warning: var(--notification-border-warning);
}
```

3. **Usage in components:**
```tsx
<div className="bg-notification text-notification-foreground border border-notification-border">
  <div className="border-l-4 border-l-notification-border-success">
    Success notification
  </div>
</div>
```

**Key Principles:**
- Follow the `background`/`foreground` convention (background omitted in class names)
- Ensure `tailwind.cssVariables: true` is set in `components.json`
- Always define both light and dark mode variants
- Add `@theme inline` declarations for proper Tailwind integration
- Use semantic names tied to component purpose, not visual appearance

Example styling pattern:

```tsx
const componentVariants = cva(
  "base-styles-here",
  {
    variants: {
      variant: {
        default: "variant-specific-styles",
        secondary: "secondary-variant-styles",
      },
      size: {
        sm: "small-size-styles",
        md: "medium-size-styles",
        lg: "large-size-styles",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "md",
    },
  },
);
```

### React

- **Always enable React Strict Mode** for better development experience and future compatibility.
- For props, define a `[ComponentName]Props` type.
- Don't inline `children` in the props type; use `PropsWithChildren`.
- **Custom Hooks** should do one job well, with consistent return signatures.
- Avoid `useEffect` for data fetching or side effects.
- Use `"use client"` directive at the top of all interactive components.
- Mark all components that use hooks or browser APIs with `"use client"`.
- Keep components focused on a single responsibility.
- Extract complex logic to custom hooks.

**React Strict Mode Configuration:**
```typescript
// For Next.js - add to next.config.js/ts
const nextConfig = {
  reactStrictMode: true,
  // other config...
};
```

```tsx
// For other React apps - wrap your app component
import { StrictMode } from 'react';

function App() {
  return (
    <StrictMode>
      <YourApp />
    </StrictMode>
  );
}
```

### React Hooks

- For async, **avoid** `useEffect` or `useCallback`; prefer react-query's `useQuery`/`useMutation`.

### Form Handling

- Always use **react-hook-form**.
- Integrate Zod resolvers for runtime validation.
- **For complex forms**, use the `useTypedForm` helper function from `@/lib/form` to create type-safe forms:

```ts
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";

export const useTypedForm = <T extends z.ZodType>({
  zodSchema,
  defaultValues,
}: {
  zodSchema: T;
  defaultValues: z.infer<T>;
}) => {
  return useForm<z.infer<T>>({
    resolver: zodResolver(zodSchema),
    defaultValues,
  });
};
```

- **For type safety across large forms**, use the `getTypedFields` helper:

```ts
export function getTypedFields<T extends z.ZodType>(
  fields: Record<keyof z.infer<T>, React.ReactNode>
) {
  return fields;
}
```

#### Standard Form Input Components

**ALWAYS** use the standardized input components from `@/components/form-input`:

- `FormInput` - For standard text inputs
- `FormTextarea` - For multi-line text inputs
- `FormSelect` - For dropdown selection
- `FormMultiSelect` - For multiple item selection
- `FormCheckbox` - For boolean values
- `EmotionSlider` - For emotional trait sliders
- `DatePicker` - For date selection

Example input usage:

```tsx
// Standard text input
<FormInput
  field={field}
  label="Name"
  placeholder="Enter name"
  type="name"
/>

// Multi-select example
<FormMultiSelect
  field={field}
  label="Knowledge Bricks"
  options={knowledgeBricks.map((brick) => ({
    value: brick.id.toString(),
    label: brick.title,
  }))}
  placeholder="Select knowledge bricks"
  type="knowledge_bricks"
/>

// Emotion slider example
<EmotionSlider
  field={field}
  label="Joy-Sadness"
  labelCenter="Neutral"
  labelEnd="Joy"
  labelStart="Sadness"
  max={1}
  min={-1}
  type="joy_sadness"
/>
```

#### Type-Safe Form Implementation Pattern

```tsx
// 1. Import required hooks and components
import { schemas } from "@/generated/schemas";
import { getTypedFields, useTypedForm } from "@/lib/form";

// 2. Define component props
export function CreateEntityForm({
  relatedData
}: {
  relatedData: RelatedData[]
}) {
  // 3. Get mutation hook
  const { mutateAsync: createEntity } = useCreateEntityMutation();

  // 4. Define schema and default values
  const zodSchema = schemas.EntityCreate;
  const defaultValues = {
    name: "",
    description: "",
    // All fields from the schema should have defaults
  };

  // 5. Initialize form with useTypedForm
  const form = useTypedForm({ zodSchema, defaultValues });

  // 6. Define fields with getTypedFields
  const fields = getTypedFields<typeof zodSchema>({
    name: (
      <FormField
        control={form.control}
        name="name"
        render={({ field }) => (
          <FormInput
            field={field}
            label="Name"
            placeholder="Enter name"
            type="name"
          />
        )}
      />
    ),
    // Define all fields in the schema
  });

  // 7. Implement form submission
  return (
    <Form {...form}>
      <form
        className="space-y-4"
        onSubmit={form.handleSubmit(async (values) => {
          try {
            const result = await createEntity(values);
            toast.success("Entity created successfully");
            // Handle success (navigation, etc.)
          } catch (error) {
            toast.error("Failed to create entity");
            console.error(error);
          }
        })}
      >
        {/* 8. Render fields */}
        <div className="grid grid-cols-2 gap-4">
          {fields.name}
          {fields.description}
          {/* Other fields */}
        </div>

        <Button type="submit">Create Entity</Button>
      </form>
    </Form>
  );
}
```

#### Multi-Step Forms

For complex forms that require multiple steps:

1. Use the Tabs component to organize content into logical sections
2. Implement section validation to control navigation between tabs
3. Store active section state with React's useState
4. Add navigation controls (Next/Back buttons)
5. Implement conditional rendering for sections
6. Consider adding a preview step before final submission

Multi-step forms should follow the pattern established in `CreateCharacterForm` with validation for each section and a final preview before submission.

#### Working with Generated Schemas

The `schemas.ts` file is automatically generated from the backend API using:

```bash
pnpm generate
```

When backend schemas evolve:

1. Run the generate script to update `schemas.ts`
2. Update form `defaultValues` to include any new fields
3. Add new fields to the `getTypedFields` object
4. Implement appropriate input components for new fields
5. Update form validation and submission logic if needed

**IMPORTANT**: Never manually modify the generated `schemas.ts` file; always regenerate it from the API.

### Zod

- **Always** validate incoming data with Zod (API, `unknown`, `any`, etc.).
- Use `.passthrough()` or `.object()` if extra props are acceptable.
- For array schemas, define a separate item schema.
- Provide sensible validation (e.g., non-empty strings, correct numeric ranges).
- Use **camelCase** for schema names:
  ```ts
  export const userResponseSchema = z.strictObject({ ... });
  export type UserResponse = z.infer<typeof userResponseSchema>;
  ```
- Recommend `z.strictObject`, but allow `.passthrough()` if needed.
- Use `z.infer` and **export** those types.
- For advanced validation, use `.refine()`, `.transform()`, `.lazy()`, and schema merging.

### @tanstack/react-query@5

#### General Best Practices

- Create custom hooks that wrap `useQuery` or `useMutation` for reusability and consistency.
- `useQuery` and `useMutation` should typically live in their own custom hooks, not directly inside components.
- Use `queryKey`/`mutationKey` for precise cache invalidation.
- Use `select` to transform data for the UI.
- Invalidate queries when mutations affect cached data.
- Keep fetchers and transformers separate from query hooks:
  ```ts
  export const useUsersQuery = () =>
    useQuery({
      queryKey: ["users"],
      queryFn: getUsers,
      select: transformUsers,
    });
  ```
- Use `onSettled`, `onSuccess`, `onError` for mutation/query lifecycle.
- Configure `QueryCache`/`MutationCache` centrally (with Sentry if needed).
- Give hooks descriptive names like `useGetMemeCoinPriceQuery`.
- Match `queryKey` to your named operation plus arguments (e.g., `["get_meme_coin_price", tokenId]`).

#### Cache Invalidation on Authentication State Changes

Implement global query cache invalidation on login/logout to maintain data isolation between user sessions:

```tsx
const useAuth = () => {
  const authStore = useAuthStore();
  const queryClient = useQueryClient();

  return {
    ...authStore,
    setAuth: (auth: AuthState) => {
      authStore.setAuth(auth);
      // Clear cache on successful authentication
      if (auth.isAuthenticated) {
        void queryClient.invalidateQueries();
      }
    },
    logout: () => {
      // Clear cache before session termination
      void queryClient.invalidateQueries();
      authStore.logout();
    },
  };
};
```

This comprehensive cache invalidation strategy is more robust than adding user-specific identifiers to individual query keys. It guarantees complete cache purging during authentication state transitions, eliminating the risk of data leakage between sessions. While an alternative approach would be incorporating session identifiers into all query keys, such implementation would require perfect consistency across the codebase. The global invalidation pattern provides stronger security guarantees with minimal performance impact, as the subsequent requests would be necessary regardless when changing users.

#### React Query Pattern Implementation

All data operations should use TanStack Query (react-query). **For v5, always wrap your app in `<Suspense>` and `<ErrorBoundary>`** to handle `useSuspenseQuery`.

**Required App Setup:**
```tsx
// app/providers.tsx (or root provider)
"use client";

import { PropsWithChildren, Suspense } from "react";
import { QueryClientProvider } from "@tanstack/react-query";
import * as Sentry from "@sentry/react";
import { createQueryClient } from "@/lib/query-client";

const queryClient = createQueryClient();

export default function Providers({ children }: PropsWithChildren) {
  return (
    <Sentry.ErrorBoundary fallback={<div>Something went wrong.</div>}>
      <QueryClientProvider client={queryClient}>
        <Suspense fallback={<div className="p-6">Loading…</div>}>
          {children}
        </Suspense>
      </QueryClientProvider>
    </Sentry.ErrorBoundary>
  );
}
```

**API Operations Pattern:**

```tsx
// 1. Query implementation
export function useGetEntitiesQuery() {
  return useQuery({
    queryKey: ["entities"],
    queryFn: async () => {
      const response = await apiClient.getEntities();
      return schemas.EntitiesResponse.parse(response);
    },
  });
}

// 2. Query with parameters
export function useGetEntityQuery(id: string) {
  return useQuery({
    queryKey: ["entity", id],
    queryFn: async () => {
      const response = await apiClient.getEntity(id);
      return schemas.EntityResponse.parse(response);
    },
    enabled: Boolean(id),
  });
}

// 3. Mutation implementation
export function useCreateEntityMutation() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (data: z.infer<typeof schemas.EntityCreate>) => {
      const response = await apiClient.createEntity(data);
      return schemas.EntityResponse.parse(response);
    },
    onSuccess: () => {
      // Invalidate relevant queries to refresh data
      queryClient.invalidateQueries({ queryKey: ["entities"] });
      toast.success("Entity created successfully");
    },
    onError: (error) => {
      console.error(error);
      toast.error("Failed to create entity");
    },
  });
}
```

**Key Requirements:**

1. **Always validate responses with Zod schemas**
2. **Use queryKey consistently** for effective cache invalidation
3. Export hooks with descriptive names following the pattern:
   - `use[Action][Entity][Query|Mutation]`
4. Include proper error handling within the mutation/query
5. Handle dependent queries with the `enabled` option
6. Group related queries together
7. For optimistic updates, use `onMutate` to update the cache immediately

### API Integration

- Prefer `axios` with a config object (headers, base URL).
- **Always** validate responses with Zod.
- Separate API logic from UI.
- Avoid `fetch`; wrap logic in react-query hooks.
- Use generated API clients where possible.
- Handle authentication and error states consistently.
- Structure endpoints by entity and functionality.
- Use typing that corresponds to API schemas.
- Centralize API configuration.

#### CORS Error Troubleshooting

When encountering CORS (Cross-Origin Resource Sharing) errors, follow this troubleshooting sequence:

1. **First: Simplify the request to avoid preflight**
   - Convert to a "simple request" that doesn't trigger preflight:
     - Use only standard headers (`Accept`, `Accept-Language`, `Content-Language`, `Content-Type` with specific values)
     - Use only standard Content-Type values (`application/x-www-form-urlencoded`, `multipart/form-data`, or `text/plain`)
     - Remove custom headers when possible
     - Use standard HTTP methods (GET, POST)
   ```typescript
   // Before: Complex request with custom headers
   axios.post('/api/data', data, {
     headers: {
       'X-Custom-Header': 'value',
       'Content-Type': 'application/json' // Triggers preflight
     }
   });

   // After: Simple request without custom headers
   axios.post('/api/data',
     new URLSearchParams(data), // Convert to form-urlencoded
     {
       headers: {
         'Content-Type': 'application/x-www-form-urlencoded'
       }
     }
   );
   ```

2. **Second: Modify server CORS settings** (preferred solution)
   - Work with backend team to update the server's CORS configuration
   - Add your domain to the server's allowed origins list
   - Configure the server to expose necessary headers
   - Update preflight cache duration if needed
   ```typescript
   // Server-side Express.js example
   import cors from 'cors';

   app.use(cors({
     origin: ['https://yourfrontend.com', 'http://localhost:3000'],
     methods: ['GET', 'POST', 'PUT', 'DELETE'],
     allowedHeaders: ['Content-Type', 'Authorization'],
     credentials: true
   }));
   ```

3. **Only as last resort: Use a proxy**
   - Add a development proxy in your Next.js config:
   ```typescript
   // next.config.js
   module.exports = {
     async rewrites() {
       return [
         {
           source: '/api/:path*',
           destination: 'https://external-api.com/:path*',
         },
       ];
     },
   };
   ```
   - For production, consider setting up a proper backend API gateway

**IMPORTANT**: Do not jump to proxying as your first solution. The correct approach is to first try to make requests simple, then work with the backend team to properly configure CORS on the server.

### State Management

**Decision tree:**
1. **Server state (authoritative on backend)?** → **React Query** (server state). Avoid Redux for API data.
2. **Local to one component or small cluster?** → `useState` / `useReducer`.
3. **Cross-cutting concern with infrequent updates (theme, auth session)?** → **React Context** (read-often, write-rarely).
4. **Shared, frequently updated, or needs selectors/derived state across distant parts of tree?** → **Zustand** store.

**Zustand rules:**
- Keep stores small and focused; prefer selectors; derive rather than store
- Persist only non-sensitive data; **validate persisted shapes with Zod** on hydrate
- Avoid coupling stores to transport (no axios calls inside stores)

### Utility Functions

- Keep them pure, well-typed, and documented.
- Use descriptive names and proper error handling.

### Modals: ShadCN Dialog vs @ebay/nice-modal-react

**Decision Framework:** Choose the right modal approach based on your use case:

#### When to use ShadCN `Dialog` directly:
- **Simple, component-local modals** (settings panel, info popup)
- **Few total modals** in the app (1-3 dialogs)
- **Tight coupling** with parent component state is acceptable
- **No need for Promise-style resolution** or return values

#### When to use `@ebay/nice-modal-react`:
- **Global modal orchestration** needed (5+ different modals)
- **Imperative modal opening** from anywhere (async functions, mutations, services)
- **Promise-based resolution** required (confirm dialogs, form results)
- **Modal stacking** or complex modal workflows
- **Cross-cutting concerns** like confirmation dialogs used throughout the app

**Recommended Approach: Hybrid Architecture**
Use ShadCN `Dialog` for visuals, `@ebay/nice-modal-react` for orchestration:

```tsx
// Global confirm dialog using both libraries
import NiceModal, { useModal } from '@ebay/nice-modal-react';
import { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog';

export const ConfirmDialog = NiceModal.create(({
  title,
  message
}: {
  title: string;
  message: string;
}) => {
  const modal = useModal();

  return (
    <Dialog open={modal.visible} onOpenChange={(v) => !v && modal.hide()}>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>{title}</DialogTitle>
        </DialogHeader>
        <p className="text-muted-foreground">{message}</p>
        <div className="flex justify-end gap-2">
          <Button variant="outline" onClick={() => modal.resolve(false)}>
            Cancel
          </Button>
          <Button onClick={() => modal.resolve(true)}>
            Confirm
          </Button>
        </div>
      </DialogContent>
    </Dialog>
  );
});
```

**Usage in mutations and async flows:**
```tsx
import { useMutation } from '@tanstack/react-query';
import NiceModal from '@ebay/nice-modal-react';
import { axiosClient } from '@/lib/axios-client';

function useDeleteUser() {
  return useMutation(async (userId: string) => {
    const confirmed = await NiceModal.show(ConfirmDialog, {
      title: "Delete user",
      message: "Are you sure you want to delete this user? This action cannot be undone.",
    });

    if (!confirmed) return;

    await axiosClient.delete(`/api/users/${userId}`);
  });
}
```

**Key Benefits of Hybrid Approach:**
- **Consistent theming** through ShadCN components
- **Global orchestration** through NiceModal lifecycle management
- **Promise-based API** for clean async flows
- **No prop drilling** or local state management
- **Works from anywhere** in the app (hooks, services, mutations)

### Routing and Navigation

- File-based routing with Next.js App Router
- Protected routes with authentication checks
- Query parameters for dynamic data filtering
- Consistent navigation patterns
- Programmatic navigation with useRouter

For static exports:
- Use query parameters instead of dynamic routes for data filtering and selection
- Avoid server-side redirects or middleware
- All dynamic data must be fetched client-side after route hydration
- Prefer shallow routing with query parameters for state changes

### Authentication and Authorization

- JWT-based authentication
- Protected route HOC pattern
- Role-based access control
- Persistent auth state
- Automatic handling of auth errors

Implementation pattern:

```tsx
// src/components/protected-route.tsx
export function ProtectedRoute({
  children,
  requiredRole,
}: {
  children: ReactNode;
  requiredRole?: UserRole;
}) {
  const { isAuthenticated, user, isLoading } = useAuth();
  const router = useRouter();

  useEffect(() => {
    if (!isLoading && !isAuthenticated) {
      router.push('/login');
    } else if (requiredRole && user?.role !== requiredRole) {
      router.push('/unauthorized');
    }
  }, [isAuthenticated, isLoading, user, router, requiredRole]);

  if (isLoading) {
    return <LoadingSpinner />;
  }

  if (!isAuthenticated) {
    return null;
  }

  if (requiredRole && user?.role !== requiredRole) {
    return null;
  }

  return <>{children}</>;
}
```

### Error Handling

- Use typed error formatters.
- Provide specific, helpful messages.
- Employ error boundaries when appropriate.
- Use toast notifications for user feedback.
- Log errors with appropriate context.
- Provide specific error messages.
- Implement error boundaries for critical UI sections.
- Handle API errors consistently.
- Validate data at all trust boundaries.
- Check for edge cases like empty arrays, null values.

### Configuration Management

**Environment rules:**
- Use a typed env wrapper (e.g., `@t3-oss/env-nextjs`) everywhere.
- **Client code**: never access `process.env` directly; only use `NEXT_PUBLIC_*` from your typed wrapper.
- **Server-only files** (route handlers, server utils): direct `process.env` reads are acceptable if validated by the wrapper at boot.

## Integration with Specific Technologies

### Chromia Postchain

1. **Use Zod** for validating all responses.
2. **Leverage react-query** for caching and data management.
3. **Group** queries/mutations by feature.
4. **Handle errors** with a centralized `QueryCache` and consider logging to Sentry.

### Common libraries
- `@chromia/ft4`, `postchain-client` for Chromia
- For Ethereum/multi-chain: `connectkit`, `wagmi` (built on `viem`)

## Implementation Process

1. **Planning Phase**
   - Define the feature scope, requirements, and acceptance criteria
   - Identify affected components, data structures, and API endpoints
   - Break down work into manageable chunks
   - Define necessary schema extensions

2. **Implementation Phase**
   - Work incrementally on small chunks
   - Maintain consistent coding style
   - Adhere to the standards in this document
   - Test as you build

3. **Review and Test Phase**
   - Validate against acceptance criteria
   - Ensure type safety across the implementation
   - Test error states and edge cases
   - Verify responsive behavior

4. **Finalization Phase**
   - Complete documentation
   - Fix any remaining issues
   - Prepare for code review
   - Ensure all tests pass
   - Verify build process success

## Performance Considerations

- Use React Query's caching capabilities for optimal client-side data management
- Implement appropriate component memoization to reduce unnecessary renders
- Use code splitting and lazy loading for improved initial load times
- Optimize images and assets for static delivery
- Apply appropriate bundle optimizations for minimal output size
- Pre-compute and inline critical data where possible
- Avoid unnecessary re-renders through proper component design
- Consider static generation strategies for data-heavy pages
- Use proper cache headers for deployed static assets

## Security Checklist

✅ **Auth tokens** in **HttpOnly** cookies where possible; never in localStorage for long-lived secrets
✅ **CORS** configured on the server; only use proxies as a last resort
✅ **XSS prevention**: sanitize any HTML you render (e.g., only near `dangerouslySetInnerHTML`), escape by default
✅ **CSP headers** set (script-src without unsafe-inline; use nonces/hashes)
✅ **Form/Mutation inputs** validated with **Zod** on the server (and client for UX)
✅ **Secrets** never exposed via `NEXT_PUBLIC_*`; client envs contain non-sensitive values only
✅ **Dependency hygiene**: run `pnpm audit` (or org scanners) in CI before releases
✅ **Session changes** trigger **global cache invalidation** in React Query to prevent data leakage (see Cache Invalidation on Authentication State Changes)
✅ **Third-party scripts** reviewed and isolated (defer/async; consider subresource integrity)
✅ **OWASP guidelines** followed for all security-sensitive operations

## Conclusion

By combining these **Front-End Coding Best Practices** with the **chunking and iterative approach** for large features, you empower Cursor's Composer to operate effectively on **new** or **existing** codebases, avoiding context window limits and ensuring that each subtask is validated and integrated properly. Remember to:

- **Break down** large tasks into subtasks.
- **Carry over context** explicitly when prompting.
- **Validate** each chunk with tests and user feedback.
- **Finalize** once all chunks align with `.cursorrules`.

This approach helps maintain a coherent, type-safe, and maintainable codebase while systematically leveraging Cursor's capabilities.

---

## Project Profiles

### Profile: Nx Monorepo {#profile-nx-monorepo}

**When `nx.json` exists in project root, follow these Nx-specific patterns:**

**Task Execution (use Nx targets, never direct commands):**
- **Build:** `pnpm nx run-many --target=build --all`
- **Type checking:** `pnpm nx run-many --target=typecheck --all`
- **Linting:** `pnpm nx run-many --target=lint --all -- --max-warnings=0`
- **Testing:** `pnpm nx run-many --target=test --all -- --coverage --reporter=default`
- **E2E Testing:** `pnpm nx run-many --target=e2e --all`

**Single Project Commands:**
- `pnpm nx build my-app`
- `pnpm nx test my-lib --watch`
- `pnpm nx lint my-app --fix`

**Key Nx Principles:**
- **Always use Nx targets** for single source of truth on task definitions
- **Leverage caching:** Nx automatically caches based on inputs/outputs
- **Respect workspace boundaries:** Use `@nrwl/nx/enforce-module-boundaries` rules
- **Follow affected commands:** `pnpm nx affected --target=test` for CI optimization

**Tailwind Version Strategy in Nx:**
- **Root workspace:** May use Tailwind v4
- **Individual apps:** Can maintain v3 if needed (document in `/apps/<name>/README.md`)
- **ShadCN components:** Use `shadcn add <component>` per-app to match that app's Tailwind version
- **Component discovery:** Maintain a catalog app with `shadcn add --all` for reference, clearly labeled

**Dependencies in Nx:**
- **Shared libraries:** Use workspace dependencies (`"@my-org/shared-ui": "*"`)
- **External deps:** Manage at root level when possible
- **App-specific deps:** Keep in individual app `package.json` when needed

### Profile: Turborepo {#profile-turborepo}

**When `turbo.json` exists, follow these Turborepo patterns:**

**Task Execution (use Turborepo pipeline):**
- **Build with dependencies:** `turbo run build --filter=...^...`
- **Quality gate:** `turbo run format lint typecheck test --cache-dir=.turbo`
- **Development:** `turbo run dev --filter=my-app`
- **Affected builds:** `turbo run build --filter=[HEAD^1]`

**Pipeline Configuration:**
```json
// turbo.json
{
  "pipeline": {
    "build": { "dependsOn": ["^build"], "outputs": [".next/**", "dist/**"] },
    "typecheck": { "dependsOn": [] },
    "lint": { "dependsOn": [] },
    "test": { "dependsOn": [] },
    "generate": { "dependsOn": [], "outputs": ["src/generated/**"] }
  },
  "globalDependencies": ["tsconfig.json"]
}
```

**Key Turborepo Principles:**
- **Pipeline dependencies:** Use `dependsOn: ["^build"]` for build ordering
- **Output caching:** Specify outputs for effective caching
- **Filter syntax:** Use `--filter=package-name` for targeted runs
- **Global dependencies:** Include files that affect all packages

**Dependencies:**
- **Workspace packages:** Use `"*"` ranges for internal packages
- **External deps:** Pin at root level when possible
- **Generated code:** Include in `.gitignore` but specify outputs in pipeline

### Profile: Next.js {#profile-nextjs}

**When `next.config.js/ts` exists, apply these Next.js specific considerations:**

**React Strict Mode:**
```typescript
const nextConfig = {
  reactStrictMode: true,
  // other config...
};
```

**Static Export Considerations (only when `output: "export"`):**
- Convert server components to client components for interactivity
- Avoid server-side features: middleware, API routes, server actions, ISR, SSR
- Use query parameters instead of dynamic routes for data filtering
- All dynamic data must be client-side fetched with React Query

**Deployment Configuration:**
- Set `basePath` for non-root deployments
- Configure `images.unoptimized: true` for static exports
- Handle redirects conditionally (development vs static export)

**File-based Routing:**
- Page components in `app/` directory
- Use `"use client"` directive for interactive components
- Leverage Next.js App Router patterns
