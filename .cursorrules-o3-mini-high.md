# .cursorrules: Comprehensive Guidelines for Cursor's Composer and Front-End Best Practices

global:
feature_name: "HugeFeatureImplementation"
context_window_token_limit: 2000 # Maximum token count per context chunk.
chunk_size_token_limit: 1000 # Recommended token count for each generated chunk.
resume_strategy: "checkpoint_summary" # Strategy to resume work using detailed checkpoint summaries.
target_codebase: "existing" # Supports both "existing" and "new" projects.

code_style:
dependency_management: >
Use project-specified dependencies. For data fetching, **react-query** must be used (avoid useEffect and direct fetch calls).
For form handling, rely on **react-hook-form** with Zod integration.
For styling, use **Tailwind CSS + ShadCN/UI + cn()**; avoid inline styles.
formatting_rules: >
Adhere strictly to ESLint and Prettier configurations as defined in the project, along with the strictest TypeScript rules.
module_pattern: >
Use ES modules with explicit import statements. Prefer barrel files for directory-level exports when appropriate.
naming_conventions: >
Use descriptive names and full flag names (e.g. use `--no-emit` instead of `-n`) and explicit identifiers (e.g. React.FunctionComponent rather than React.FC).

workflow:
planning_phase:
description: >
Outline the feature scope, expected behavior, and tasks before any code is generated.
This is like gathering all ingredients before starting to bake a cake or writing down the recipe steps.
Verify if a corresponding section exists in `progress.md`. If not, create a checklist that covers: - Feature scope and behavior. - Key components/modules to add or modify. - File names to create or change, and what they should contain. - Dependencies and prerequisites. - Edge cases and error handling. - Adherence to all relevant rules (Zod, react-query, Tailwind CSS, etc.).
expected_output: "A detailed checklist outlining the feature tasks."

analysis_phase:
description: >
Analyze the existing codebase to identify integration points and dependencies.
Think of this as studying the musical score before adding a new movement.
expected_output: "A summary report of the current architecture and identified integration points."

implementation_phase:
description: >
Divide the huge feature into manageable chunks that fit within the LLM's context window.
Each chunk must: - Follow front-end best practices. - End with a checkpoint summary (like bookmarking a recipe step) that details what was implemented and what remains.
chunking_method: >
Split the work by functional components (UI elements, API endpoints, utilities) using the checklist from `progress.md`.
checkpoint_instruction: >
At the end of each chunk, output a detailed checkpoint summary including: - Code changes made. - Remaining tasks. - Context recap for resuming work.

review_phase:
description: >
Integrate all code chunks and perform a final review. Confirm that: - The entire feature adheres to project conventions and best practices. - All tests are updated and passing. - Documentation (e.g. CHANGELOG.md and progress.md) is current.
This phase is like a final rehearsal ensuring that every section of the orchestra plays in harmony.
expected_output: "A cohesive, error-free feature integrated into the codebase."

error_handling:
self_correction: >
After each chunk is generated, validate the code for syntax and logical errors.
If errors are detected, re-generate or correct the affected chunk.
(Imagine tasting a dish during cooking to ensure the flavors are balanced.)

resume:
resume_instruction: >
When the context window limit is reached, output a detailed checkpoint summary.
On subsequent runs, prepend this summary to the prompt to ensure seamless continuation,
much like using a bookmark to resume reading a long novel.

frontend_best_practices: |

# Front-End Coding Best Practices

## Before You Start

- **Identify Applicable Rules:** Figure out which rules apply to the feature (e.g., if data fetching is involved, use react-query; for forms, use react-hook-form with Zod).
- **Repeat Relevant Rules:** Include the relevant rules in your output for transparency.

### Most Important Mandates

- **USE:**
  - **react-query** for async data fetching and caching (instead of using useEffect or direct fetch).
  - **Zod** to validate all API responses and form inputs.
  - **Tailwind CSS + ShadCN/UI + cn()** for styling and composing class names.
  - **react-hook-form** for form handling.
  - **Zustand** for non-context or persistent client-side state.
  - **@ebay/nice-modal-react** for modals.
- **AVOID:**
  - Using useEffect for data fetching.
  - Direct fetch calls; instead, use dedicated API hooks or clients.
  - Inline styles; rely on Tailwind classes or class-variance-authority.
  - Mutating data or using for-loops; favor immutability and array methods like map/filter.

## Large Feature Implementation Guidelines

1. **Planning Phase:** Create or check the feature outline in `progress.md` using a checklist.
2. **Implementation Phase:** Follow the checklist, tackle each item, and update `progress.md` as you complete tasks.
3. **Review & Documentation Phase:** Update CHANGELOG.md, tests, and confirm the feature meets outlined goals.
4. **Finalization & Commit:** Ensure code adheres to conventions, update documentation, and post a summary in `progress.md`.

file_structure: |

# File Structure Guidelines

- **Naming:** Use kebab-case for filenames.
- **Extensions:** Use `.tsx` for TypeScript with JSX; `.ts` otherwise.
- **Testing:** Name test files as `[filename].test.ts` or `[filename].test.tsx`.
- **Example Modular Structure:**

  src/
  app/ # Next.js app structure (pages, layouts, etc.)
  users/ # Feature-specific files for "users"
  page.ts # Main page importing necessary components
  create-user-form.tsx # Component using react-hook-form
  use-create-user-modal.tsx # Hook using @ebay/nice-modal-react
  components/ # Reusable React components
  ui/ # ShadCN UI components
  common/ # Common components across features
  contexts/ # React context providers
  lib/ # Project-level utilities
  api.ts
  constants.ts
  postchain-client.ts
  utils/
  format.ts
  convert.ts
  hooks/ # Global React hooks
  providers/ # Context providers
  queries/ # React Query queries/mutations
  schemas/ # Zod schemas
  stores/ # Zustand or other state management

code_readability: |

# Code Readability Guidelines

- **Readability Over Conciseness:** Prioritize clear, understandable code.
- **Naming:** Use descriptive names (e.g., isUserAuthenticated()).
- **Explicit Syntax:** Prefer explicit over shorthand (e.g., React.FunctionComponent instead of React.FC, disabled={true}).
- **Documentation:** Comment workarounds and break large functions into smaller ones.
- **Constants:** Avoid magic numbers; use named constants.

syntax_and_programming_style: |

# Syntax & Programming Style

- Use nullish coalescing (??) over logical OR (||) for default values.
- Favor immutable programming and pure functions.
- Use specific error types (TypeError, RangeError, etc.) and add a default case in switch statements.

command_line: |

# Command Line Guidelines

- When generating code, always use long flags (e.g., `--no-emit` instead of `-n`, `prettier --write .` instead of `prettier -w .`).
- Document shell scripts thoroughly.
- Name environment variables and package.json scripts descriptively.
- Use explicit exit codes for error conditions.

node_setup: |

# Node.js Setup

- Ensure `.nvmrc` reflects the Node.js version in use.
- Verify that package.json's `packageManager` and `engines.node` match the project's Node.js version.
- Keep `@types/node` aligned with the Node version.

package_json_scripts: |

# package.json Scripts

Ensure scripts include (if missing, append):
{
"scripts": {
"build": "next build",
"dev": "next dev",
"format": "prettier --write .",
"lint": "eslint --cache",
"prepare": "husky",
"spellcheck": "cspell --config=cspell.json \"\*_/_.{cjs,js,md,mjs,ts,tsx}\" --no-progress --show-context --show-suggestions",
"start": "next start",
"typecheck": "tsc --noEmit"
}
}

tsconfig: |

# tsconfig.json Guidelines

Use configurations such as: - `@tsconfig/strictest` - `@tsconfig/nodeXX` (replace XX with your Node version) - `@tsconfig/next` (if using Next.js)

Example (for Next.js):
{
"extends": [
"@tsconfig/strictest/tsconfig.json",
"@tsconfig/next/tsconfig.json"
],
"compilerOptions": {
"baseUrl": ".",
"paths": { "@/_": ["./_"] }
},
"include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
"exclude": ["node_modules"]
}

exports_and_imports: |

# Exports & Imports

- Regularly remove unused exports.
- Export items near their declarations rather than aggregating at the file's bottom.
- Avoid default exports (except in Next.js pages).
- Import using short paths (e.g., `@/components/ui`) and maintain concise paths from the project root.

tailwind_css: |

# Tailwind CSS & ShadCN Guidelines

- Use `import { cn } from "@/lib/utils";` to merge conditional classes.
- Never construct class names using string concatenation.
- Avoid inline styles; use Tailwind or class-variance-authority.
- Extend the Tailwind config to define design tokens and avoid magic numbers.
- Use ShadCN CSS variables for consistent theming.
- Utilize `cva` from class-variance-authority for handling component style variations.

typescript_guidelines: |

# TypeScript Guidelines

- Leverage discriminated unions for state variations.
- Use `as const` to preserve literal types.
- Prefer `satisfies` over `as` for better type safety.
- Use `type` for local/complex unions and `interface` for public contracts.
- Avoid `any`, `as`, and unchecked type assertions; use Zod for strict validation.
- Employ utility types (Partial, Pick, Omit, etc.) and use the strictest TS configuration available.

zod_guidelines: |

# Zod Guidelines

- Always validate incoming data (API responses, form inputs) with Zod.
- Use `.passthrough()` or `.object()` depending on whether extra properties are acceptable.
- For arrays, define a separate item schema.
- Ensure validations (non-empty strings, correct numeric ranges) are sensible.
- Follow camelCase naming for schemas.

react_query_guidelines: |

# @tanstack/react-query@5 Guidelines

- Never place useQuery or useMutation directly inside components; define them at module scope.
- Use `queryKey`/`mutationKey` for precise cache invalidation.
- Use the `select` option to transform data for the UI.
- Invalidate queries when mutations affect cached data.
- Separate fetchers and transformers from query hooks.
- Utilize lifecycle methods (`onSettled`, `onSuccess`, `onError`) for robust handling.
- Configure QueryCache/MutationCache centrally (integrate Sentry if needed).
- Use descriptive hook names (e.g., `useGetMemeCoinPriceQuery`), matching queryKeys with operation names and parameters.

chromia_postchain: |

# Chromia Postchain Guidelines

- Use Zod to validate all responses.
- Leverage react-query for caching and state management.
- Group queries and mutations by feature.
- Handle errors with a centralized QueryCache and log issues (e.g., to Sentry).

form_handling: |

# Form Handling Guidelines

- Always use **react-hook-form**.
- Integrate Zod resolvers for runtime validation in forms.

utility_functions: |

# Utility Functions

- Ensure utility functions are pure, well-typed, and well-documented.
- Use descriptive names and implement robust error handling.

react_hooks_guidelines: |

# React Hooks Guidelines

- For asynchronous operations, avoid using useEffect or useCallback in favor of react-query’s hooks.

react_guidelines: |

# React Guidelines

- Define a `[ComponentName]Props` type for component props.
- Do not inline children; use PropsWithChildren.
- Custom hooks should have a single responsibility and consistent return signatures.

api_integration: |

# API Integration Guidelines

- Prefer using axios with a configuration object.
- Always validate API responses with Zod.
- Separate API logic from UI components.
- Avoid using fetch directly; instead, encapsulate it in react-query hooks.

error_handling_detailed: |

# Detailed Error Handling

- Use typed error formatters with specific, helpful messages.
- Implement error boundaries where applicable.

configuration_management: |

# Configuration Management

- Use typed configuration for environment variables.
- Avoid accessing process.env directly; use a configuration library or abstraction.

integration_with_chromia: |

# Integration with Chromia Ecosystem

- For Chromia, use libraries like `@chromia/ft4` and `postchain-client`.
- For Ethereum/multi-chain, consider using `connectkit` and `wagmi` (built on viem).

conclusion: |

# Conclusion

Adherence to these rules ensures a consistent, type-safe, and maintainable codebase.
When generating or editing code, always reference the relevant rules, repeat them in your output,
and verify that no disallowed patterns are introduced.
This comprehensive .cursorrules file guides Cursor's Composer in implementing huge features
efficiently while seamlessly integrating with both new and existing codebases.

notes: |

- **Chunking:** Breaking a huge feature into manageable pieces is like splitting a long musical composition into individual movements.
- **Checkpointing:** Adding a checkpoint summary is akin to bookmarking your place in a cookbook so you can resume exactly where you left off.
- **Explicitness:** Always use full flag names and explicit identifiers for clarity and maintainability.
